{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf600
{\fonttbl\f0\froman\fcharset0 TimesNewRomanPS-BoldMT;\f1\froman\fcharset0 TimesNewRomanPSMT;\f2\froman\fcharset0 TimesNewRomanPS-ItalicMT;
}
{\colortbl;\red255\green255\blue255;\red253\green183\blue144;}
{\*\expandedcolortbl;;\csgenericrgb\c99400\c71900\c56300;}
\pard\tx720\sl312\slmult1\pardirnatural\partightenfactor0

\f0\b\fs28 \cf0 Section - Feature: Live Coding and Interactive Development\
\

\f1\b0 A major and growing sub-movement within the computer music community is that of \'93live-coding\'94, in which performances include real-time alteration of music producing code 
\f2\i during
\f1\i0  musical playback, sometimes with code displayed visually for the audience on projected screens, etc. To a lisp user, this paradigm will be familiar as it is no different from interactive development at the REPL while a program is running in the interpreter. The term live-coding with the music communicty can encompass a variety of levels of code manipulation in real time, ranging from manipulation of scored music events to alterations of the dsp graph of an audio generation program. Scheme for Max aims to support live coding in the Max environment at the musical event level, an area that crosses over with the world of algorithmic composition, in which programs make musical decisions through algorithms and stochastic processes, which themselves may be altered during performance.  Tools that support live-coding are useful also to artists working in Max who don\'92t intend to 
\f2\i perform
\f1\i0  the live-coding. Being able to manipulate algorithms and sequencing code during playback is of major benefit to any computer music composer. A common scenario in algorithmic composition of any kind is that processes build and mutate data over time, and thus being required to stop and start the piece after any code change is often an unsatisfactory workflow - it may take some not insignificant time for the processes of the piece to get back to the part the composer is working on at any given time. Thus the act of being able to redefine musical code in real-time during playback has major advantages not just to the live-coder, but to any composer working with custom code that manipulates musical events. In this context, Scheme For Max has notable advantages over other options such as JavaScript and we will examine these advantages in this section. While there are other external interpreter objects for Max (Python, Ruby, Lua), all of these have similar implementations and limitations as the JavaScript object, and thus we will refer in our comparison to JS, with comments intended to apply to other language options as well unless otherwise indicated.\
\
There do exist numerous other music programming platforms that allow interactive development during musical playback, and Scheme for Max is not unique in this regard. In fact one of the major inspirations for Scheme for Max (and factors in the decision of which Lisp implementation to use) is \'93Common Music\'94, an algorithmic composition platform which also embeds s7 Scheme and provides this facility. Various other Lisp-based live coding and algorithmic composition environments also exist, including the Scheme based Nyquist and Extempore, and the Common Lisp based Common Lisp Music, Incudine and Slippery Chicken. However, all of these are run as stand-alone processes which must either be used for all aspects of music generation, or must send events as MIDI or network data to external audio generation tools. Scheme for Max is unique in bringing Lisp live coding facilities to the Max environment in a way that allows the sequenced events to be not only musical notes, but functions with programmatic access to all of the Max environment. Given the richness of the Max environment, Max\'92s position as the most popular music programming platform, and its unmatched integration with commercial music tools (through the Max4Live package for Ableton Live), this is a major benefit to the algorithmic composer or live-coding performer. It allows one to programmatically sequence any aspect of the composition and music production. \
\
Scheme for Max enables interactive development in several ways. Max objects are programmed to support \'93messages\'94, wherein an incoming Max message (a space-separated list of symbols or numbers) may have significance to a certain object and thus be implemented as a method on the object. For example, sending the message \'93set 99\'94 to a number object will update the internal state of the number object (but not send out the number) through it\'92s internal \'93set\'94 method. On instantiation, the s4m object instantiates an s7 interpreter, and loads and evaluates any source file given as an object argument. Following instantiation, further code can be sent to the s4m object either through \'93read\'94 messages, \'93eval-string\'94 messages, or generic space separated symbolic messages (a Max list in which the first atom is a symbol, the \'93message selector\'94 in Max nomenclature). We will discuss each of these and how they support interactive work in Max.\
\

\f0\b Interactive File Loading with the \'93read\'94 message.
\f1\b0 \
A \'93read\'94 message to s4m consists of the \'93read\'94 symbol and a filename, and will result in the file being loaded in s7 without reseting the interpreter. (A \'93reset\'94 message is also implemented should one want to reboot the interpreter without recreating the s4m object). One of the advantages of the s7 Scheme implementation is that it has been designed around the needs of the interactive computer music user, where the most likely scenario is a single developer working interactively on some small to medium sized code base for a piece of music work. To this end, developer convenience has been prioritized over linguistic strictness in various places, one such being that the interpreter allows re-defining functions or variables without requiring any special syntax. The result of this is that it is possible for a developer to implement their Scheme code in multiple files, with the main file containing function definitions and state variables that should persist, and the second, used in the \'93read\'94 message\'94, containing functions under active development, which may be reloaded anytime by sending the read message. In the author\'92s experience, developing a complex musical sequencer, this has been a significant convenience as playback functions can be redefined without the requirement of reloading sequence data and sequencer settings to hear the results of the redefinitions instantly. Further, if Max is set to run with a reasonable amount of playback latency (10ms seems to work generally), this reload does not even result in any audible interruption of playback, and could thus be done in a performance situation. This practice is not possible in the Max js object, which supports only a \'93compile\'94 message that resets the JavaScript interpreter on compile, and represents a significant differentiator for Scheme for Max.\
\

\f0\b Interactive code interpretation with the eval-string message\

\f1\b0 The second interactive development practice supported by Scheme For Max is that of sending the s4m object code in real-time as textual messages, similar to sending code to a Lisp REPL from a terminal or text editor. The s4m object implements an \'93eval-string\'94 message, consisting of the eval-string symbolic atom followed by a quoted block of Scheme code. This is helpful to the user in several ways. The first is likely the most familiar to Lisp developers: we can simulate a network REPL by receiving string content over the local network using Max objects built for this purpose. One such method is to use the Open Sound Control text protocol for communicating with musical tools over a TCP network. The Max patch can use a \'93udpreceive\'94 object to receive string messages from a networking port, and build a composite message by passing this through a \'93prepend eval-string\'94 object to send on a complete \'93eval-string\'94 message to the s4m object. (\cb2 TODO image\cb1 ). By doing so, the user can create send Scheme code from any tool capable of sending an OSC message. A recipe for doing this from the Vim editor is available in the Scheme For Max cookbook, comprised of a set of Vim keybindings and a small Python program that uses the OSC library. The developer can select a block of text (or position the cursor on an opening or closing parentheses), execute the bound keystroke, and the code enclosed is sent over the network and interpreted by the s4m object. This allows interactive development in without needing to reload entire files, and can also be used for live-coding to send function calls to Max that may trigger any actions in the Max environment. \
\
The user can also use the same pattern to create code blocks in Max messages. The message containing parenthesized code must be sent to a \'93tosymbol\'94 object, which transforms the list of space separated symbols (some of which will include parentheses) into one quoted Max symbol (which may contain spaces). This is followed by the aforementioned \'93prepend eval-string\'94 message, and then to the s4m object for evaluation. (See examples \cb2 TODO examples\cb1 ) This pattern is of great convenience during development as it enables the developer to create Max widgets that evaluate test code, with the option to use other Max objects for orchestration of the code snippets in time (e.g. to delay a second operation until the first has had time complete its work.) This facility is used extensively in the Scheme for Max regression test suite. (\cb2 Example image of regression test\cb1 )\
\
Technically, the above pattern is possible with the JS object as well, but it is more  cumbersome, and thus is not widely used. One could create a JavaScript callback function in the JS object that receives a string argument, and use JavaScript\'92s \'93eval\'94 function to evaluate the string. However, this is made cumbersome by the fact that strings are used widely as identifiers in JavaScript (e.g. object or dictionary keys), and would thus need to be escaped coming from the source, whereas in Scheme, we need only use strings (and thus quotation marks) where we specifically need strings - the vast majority of the time in developing Scheme for Max code we can use quoted symbols or Common Lisp style keywords (which are supported in s7 Scheme).\
\

\f0\b Interactive coding with plain Max messages
\f1\b0 \
Perhaps the most interesting and unusual of the Scheme for Max live coding facilities is the option to evaluate regular Max messages as Scheme code when sent directly from Max message objects, a pattern that enables rapid interactive development of user interfaces to Scheme systems with minimal code. To understand this facility, we are required to understand the Max message system in further depth.\
\
Max messages are space separated lists of atoms, where an atom may be a symbol, integer, or float, and where the first atom is considered to be a symbol representing the method to be called with the remaining atoms. (There is not really such a thing as a string type in Max - a symbol may simply contain quotation marks, though this frequently requires escaping to make work properly). A 
\f2\i message
\f1\i0 -
\f2\i object
\f1\i0  is different from a Max 
\f2\i message: 
\f1\i0 the message-object is a visual patcher object that provides facilities for users to work with messages interactively, while a message is a set of data in memory that may be sent to any object. We can type a message into the message-object and doing so sets the internal storage of the message object to store the message typed. Subsequently clicking on (or sending a bang to) the message object will then cause it to send the stored message out its outlet and on to a receiving object, which will trigger execution of the receiving object\'92s corresponding message handler (if it has one).\
\
Thus in Max, any message that begins with a symbolic selector is interpreted to be a request for the receiving object to call a method similarly named. If an object receives a message beginning with a symbol for which it has no method, it will display an error message that the operation is not supported. While it is up to the object implementer how exactly that method is implemented, the standard is that all subsequent atoms in the message are taken as arguments to the method for the selector. (On a C level, the method is generally named as \{obj\}_\{selector\}, for example the handler for the read message in the s4m object is called \'93s4m_read\'94, and is bound to the selector read by a call to \'93class_add_method\'94 in the externals main function which runs on instantiation). A message is internally stored as a pair of datums, the first a pointer to a symbol for the selector, and the second a pointer to an array of atoms which may store any Max type (int, float, symbol). Thus a message of \'93set foo 1 2.2\'94 sent from one message box to another becomes a data structure of  pointer-to-symbol \'93set\'94 and pointer-to-atom-array [\'93foo\'94, 1, 2.2], and triggers the \'93set\'94 handler of the receiving message object, which will update its storage and display accordingly.\
(Visual \cb2 EXAMPLE\cb1 ). \
\
One might think at first that numeric Max messages are an exception to this pattern, but in fact Max merely hides the selectors for them from view. If we send a Max message of \'931\'94 to an object, the message received by the object is again a selector and argument pair, with the selector filled in with the (invisible) \'93int\'94 selector. Similarly, a message of \'931 2 3\'94 will be internally implemented as: selector \'93list\'94 and argument array [1, 2, 3]. (This can be verified in Max by sending a message box the visual message \'93list 1 2 3\'94 and observing that the result is identical to sending the visual message \'931 2 3\'94 - the message box object simply hides the word \'93list\'94. (\cb2 EXAMPLE MAYBE?\cb1 ). ) \
\
A major component of programming Max on a visual level is thus the manipulation of Max messages prior to sending them to an object which does some operation with them, the execution of which may or may not result in further messages being sent out. Examples of these message-manipulating objects include the \'93prepend\'94 object, which inserts an atom at the head of the atom array, and the \'93tosymbol\'94 object, which takes all the atoms and converts them into one string atom, potentially containing spaces. In a sense, message manipulation objects act as pure functions: they receive a message, and and output a transformed message, with no other side-effects. On the other hand, objects such as the \'93print\'94 object are terminal and are called purely for their side effects: the received message is printed to the console (our side-effect), and processing ends. There exist also objects that do both, for example triggering audio playback of a file and emitting a message when complete.  \
\
Let us examine now in further detail the syntax of message objects as we work with them in the patcher. The Max message-object syntax has a few additions to space separation: the comma, the semicolon, and the dollar sign. (If a message is meant to contain the literal symbol for these characters, they can be escaped with a backslash.) The comma is used to separate messages: if we set the contents of a message object to \'93a, b\'94 and connect this to a print object, when we click (or bang) the message box, we will see two rounds of execution of the print object, printing a and then b on separate lines. The semi-colon is a shortcut for the operation of sending a message to a wireless receiver object, an operation we don\'92t need to delve into beyond knowing it has this meaning. The dollar symbol is the one of interest to us. But before we discuss it, is worth noting that the symbols of single-quote, back-tick, colon, ampersand, question mark, exclamation mark, and @ are of no significance to Max. If we use those in a space separated list of atoms in a message, Max will simply include the character as part of the atom -  :foo is one symbolic atom, as is \'91foo, foo!, foo?, `(foo, and so on. (The experienced Lisper can likely see where this is going\'85)\
\
The dollar sign, used in a message-object, instructs the object to interpolate contents from a received message into the stored message template and pass on the result. For example, if we wanted to prepend an integer message with the symbol \'93set\'94, we could either send it through a \'93prepend set\'94 object, or send it through a message-object with the contents \'93set $1\'94, and the results would equivalent. Thus if we were to send a message of \'93:my-keyword\'94 (perhaps by clicking on a message box containing this text) to a message box containing \'93set! \'91key $1\'94, the receiving message will in turn output \'93set! \'91key :my-keyword\'94. (Looking good, looking good\'85)\
\
As a consequence of these syntax rules, we can see that it is trivial, and quite natural, to generate messages that are textually valid Scheme expressions, though missing the surrounding parentheses. To take advantage of this happy accident, Scheme for Max interprets any incoming message that does not start with a selector used by the object itself (e.g. \'93reset\'94, \'93read\'94, \'93scan\'94) to be a request to evaluate the message as if it were surrounded by parentheses. Thus sending the message: \{ eval-string \'93(post :foobar)\'94 \} to the s4m object is no different than sending the message \{ post :foobar \}, and both will result in the evaluation of the Scheme expression:  (post :foobar). \
\
This facility, combined with our ability to re-define functions on the fly, has surprisingly substantial ramifications: we can now construct user interfaces to our Scheme program with nothing more than Max UI objects and message-objects added to a Max patch, and we can build and re-define both how we interact with our widgets and what they do 
\f2\i as the piece is playing
\f1\i0 . Furthermore, because of the fact that the single-quote and colon are of no significance to Max, we have a very natural way to control what is evaluated (or not) as a result of sending such a message to Max. Anything we want interpreted as a symbol gets quoted, any symbol not quoted will be taken to be a reference to a Scheme variable, and when we want to ensure a symbol is just as it appears, we can use a keyword, which always evaluates to itself. In effect, passing a Max message to the s4m object triggers a round of evaluation of a single s-expression, with a syntax that is natural for calling non-nested functions.\
 \
LEFT OFF: provide some meaty examples of this, including symbol use and keywords,\
\
\
\
\
\
\
\
}