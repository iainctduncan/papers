
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Conclusion - IN PROGRESS (2948 w) &#8212; M.Tech Thesis  documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Features and Usage (6300 words)" href="features_usage.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="conclusion-in-progress-2948-w">
<h1>Conclusion - IN PROGRESS (2948 w)<a class="headerlink" href="#conclusion-in-progress-2948-w" title="Permalink to this heading">¶</a></h1>
<p>To conclude, I will evaluate the success of the Scheme for Max project
against the high-level criteria and goals previously listed,
discuss the limitations of Scheme for Max 1.0, and introduce potential
and planned future work on Scheme for Max.</p>
<section id="evaluation">
<h2>Evaluation<a class="headerlink" href="#evaluation" title="Permalink to this heading">¶</a></h2>
<p>The project was started in 2019, with a first usable version released in early 2020.
I have thus been using S4M in musical work for three years, and have done so
in a variety of contexts: producing mainstream electronic music within the Max for Live
environment, creating algorithmic process music in standalone-Max,
creating large-scale frameworks for improvised sequencing. This has included
using Scheme for Max to control virtual synthesizers, voltage controlled analog
synthesizers, Max audio objects, the Csound engine (hosted in Max), and the
Ableton Live mixing environment through the Live API.
While there is certainly room for improvement, and there are limits in the current
incarnation to real-time performance, the project has been unequivocally successful
in meeting my personal goals for a productive, flexible, and interactive computer
music platform.</p>
<p>I will briefly discuss the success of the project against the seven goals listed
in the Goals chapter.</p>
<section id="be-focused-on-programming-musical-events-and-event-oriented-tools-rather-than-audio">
<h3>#. Be focused on programming musical events and event oriented tools, rather than audio<a class="headerlink" href="#be-focused-on-programming-musical-events-and-event-oriented-tools-rather-than-audio" title="Permalink to this heading">¶</a></h3>
<p>This goal has been met well by working in Scheme, and in the event-domain of Max.
Lisp has made creating my own abstractions of musical events simple to do, and scheduling
these with real-time performances has been successful.
I am able to “think in notes” (when desired), without the restrictions of tools like
the Csound score language.</p>
</section>
<section id="support-multiple-contexts-scored-composition-realtime-interaction-and-live-performance">
<h3>#. Support multiple contexts: scored composition, realtime interaction, and live performance<a class="headerlink" href="#support-multiple-contexts-scored-composition-realtime-interaction-and-live-performance" title="Permalink to this heading">¶</a></h3>
<p>Scoring compositions with Max is an area I have been recently exploring by creating
scoring tools with Lisp macros.
I am able to score high and low level time scales in Scheme, and this has been productive,
flexible, and readable during the compositions process.
Doing so is particularly flexible as one can, with macros, change how the macros
execute for certain tasks, allowing one to, for example, fast-forward through scores,
cueing all called functions up to some playback point.
Representing hierarchies of sections of music as functions (as opposed to just notes)
has also proven to be very productive.</p>
<p>Meeting the goal of real-time interaction has been very successful.
I am able to rapidly build programs for interacting with the system over MIDI hardware.
Having done this at various points with all of Max, JavaScript, Csound, and C++, I
can personally say that working in Scheme has sped up development tremendously.
This comes from both the ability to update only certain sections of code without restarting
pieces or programs and from the flexibility of the language and its support for symbolic
computing. There do exist limits to real-time interaction stemming from performance
issues, which I will discuss below, but these have largely been surmountable.</p>
<p>Live-performance is feasible with some caveats at this point, however, this has not yet been
tested in actual stage situations. The program is remarkably stable; while crashes from segfaults were common
during the original stages of development, this
does not happen anymore at all in my current work. I would have no hesitations
of running the program on stage for stability reasons.
However, running <em>large</em> Scheme programs while also rendering audio does, in the current incarnation,
require running with some significant latency (for garbage collection), and certain
program behaviour, such as over a hundred delay calls per second, can lead
to garbage collection issues after some time of running.
This would like be an issue for users wishing to perform
particularly long pieces that use large Scheme sequencing programs and are
rendering audio in real-time on the same computer. This is covered further
below.</p>
</section>
<section id="support-advanced-functional-and-object-oriented-programming-techniques-for-implementing-complex-algorithms">
<h3>#. Support advanced functional and object-oriented programming techniques for implementing complex algorithms<a class="headerlink" href="#support-advanced-functional-and-object-oriented-programming-techniques-for-implementing-complex-algorithms" title="Permalink to this heading">¶</a></h3>
<p>This is an area in which the project has been successful beyond my expectations.
While there is some work required of the programmer to learn advanced programming in Scheme,
resources for doing so are widely and freely available. (CITE)</p>
<p>The flexibility of being able to work on algorithms as the program runs is helpful,
and reimplementing patterns and algorithms that I have previously used in other languages
(Max, JavaScript, C, Csound) has been pleasant and fast.</p>
</section>
<section id="be-linguistically-optimized-for-the-target-use-cases">
<h3>#. Be linguistically optimized for the target use cases<a class="headerlink" href="#be-linguistically-optimized-for-the-target-use-cases" title="Permalink to this heading">¶</a></h3>
<p>Having now developed a substantial body of work in Scheme, of both music and tools for music,
I personally feel that the linguistic optimizations of Lisp, and even of Scheme in particular,
are well suited to balancing the needs of the composer-programmer and tools-programmer.
In particular, Lisp macros are emminently well-suited to this, as they
enable the tools-programmer to create very high-level abstractions that require
very little in the way of code from the composer-programmer, and for which the the code
used in pieces matches visually the way the composer wants to think about music.</p>
<p>TODO example macro</p>
<p>While it would be interesting to also try this kind of programming in a typed language
of the ML-family (OCaml, Haskell, SML), I feel that from my personal experiences,
the trade-offs between Lisp and ML languages make the Lisp family more
productive and satisfying for the immediate needs of the composer-programmer.</p>
</section>
<section id="be-usable-in-conjunction-with-modern-commercial-tools">
<h3>#. Be usable in conjunction with modern, commercial tools<a class="headerlink" href="#be-usable-in-conjunction-with-modern-commercial-tools" title="Permalink to this heading">¶</a></h3>
<p>In this area, the project has again been resoundingly successful.
I have spent much of the last year (2022-2023) developing a large-scale platform for creating music
in Ableton Live in which S4M is used for improvised sequencing, hardware control, algorithmic processes,
mix automation, and scoring. This has not only worked well, but I am able to combine
it with material coming from regular Ableton Live clips with emminently usable synchronization.
Scheme for Max introduces no further timing discrepencies that does Max for Live itself, where
jiter of up to one signal vector (approximately 1.4 ms at 44100 samples per second) is possible, and is
(usually) musically neglible.</p>
<p>Of particular note, being able to control the Live environment through the Live API with S4M has
been particularly successful. The Live API provides a way for Max patches to programmatically control
most elements of the host in real-time. It uses an object model, the Live Object Model (or LOM), that
is based on hierarchal lists of symbols, and thus lends itself well to implementation in Lisp.
For example, a function to find a Live element and send it an action requires minimal code:</p>
<p>TODO LIVE API example.</p>
</section>
<section id="support-composing-music-that-is-impractical-on-commercial-tools">
<h3>#. Support composing music that is impractical on commercial tools<a class="headerlink" href="#support-composing-music-that-is-impractical-on-commercial-tools" title="Permalink to this heading">¶</a></h3>
<p>I have found Scheme for Max particularly appropriate for composing and programming works that are
not practical on mainstream sequencers (e.g., Live, Logic, Reaper).
By using Scheme as the top-level orchestration layer, whether through score facilities
or algorithmic processes, implementing pieces with complexities such as shifting or multiple concurrent
meteres is trivial, as is manipulating time across multiple scales at once, such as gradually
changing tempos of different voices at different rates.</p>
<p>Similarly, S4M is well suited to exploring spectral music and other techniques in which the line between a
component of sound and an instrument is blurred. For example, if one wants to apply spectral composition
techniques such as controlling many partials of many sounds independently, this is straightforward by combining
Scheme for Max with the csound~ object, and far simpler than would be the case with plain Max.
Scheme programs can create programmtic loops that send Csound score messages representing activations
of sine waves.</p>
<p>Overall, I feel that the achievement of this goal is one of Scheme for Max’s strongest points,
and that S4M has the potential to be a significant contribution to the computer music tool landscape in this area.</p>
</section>
<section id="enable-interactive-development-during-musical-playback">
<h3>#. Enable interactive development during musical playback<a class="headerlink" href="#enable-interactive-development-during-musical-playback" title="Permalink to this heading">¶</a></h3>
<p>The support for interactive development has been an area in which Scheme for Max has succeeded beyond
my expectations.
For my personal work configuration, I have created two small scripts in Python and Vim respectively,
which enable me to send Scheme code to Max directly from my text editor.
This is achieved by having Vim commands send a selected area (the enclosing parenthetical expression)
to standard input (STDIN) of a short Python program, which in turn sends the text over the local
network as an Open Sound Control (OSC) message to the Max <strong>udp</strong> object, from where it is passed
to the s4m object for evaluation.</p>
<p>I am thus able to work on code in my editor, and in two keystrokes, send blocks of it to Max.
I have used this to also create hotkeys for starting and stopping Live, reloading my project,
and resetting the intrepreter, and have created short convenience functions that I can evaluate
from the editor to, for example, cue works to certain places, mute tracks, arm devices, and the like.
The results of these operations (whatever I make the functions return) are printed on the Max console,
and I am also able to use the Max console to inspect data structures interactively.</p>
<p>Of particular note is the ability to change functions even while they are scheduled.
This capability is something I have found exceptionally valuable while working on algorithmic music.</p>
<p>I feel that this is also an area where Scheme for Max can contribute significantly to the
computer music landscape, providing a live-coding platform that does not need to be insulated from
mainstream tools such as Ableton Live.</p>
</section>
<section id="evaluation-summary">
<h3>Evaluation Summary<a class="headerlink" href="#evaluation-summary" title="Permalink to this heading">¶</a></h3>
<p>In conclusion of the evaluation against our goals, I feel the project has been almost entirely successful
in meeting its stated goals.
The one area of concern that remains is suitability for live performances that use real-time interaction with
large programs and would benefit from being able to run with lower latency.
However, as the current s7 interpreter was not designed for real-time use (indeed its success in this context
came as a suprise to the author! CITE) I believe this is an area in which future work on optimizing
s7 and Scheme for Max for real-time performance will bear fruit.</p>
</section>
</section>
<section id="limitations-and-future-work">
<h2>Limitations and Future Work<a class="headerlink" href="#limitations-and-future-work" title="Permalink to this heading">¶</a></h2>
<p>Finally, I will discuss the limitations of Scheme for Max in its current incarnation and
the planned or potential work on and with the project.</p>
<section id="limited-integrations">
<h3>Limited Integrations<a class="headerlink" href="#limited-integrations" title="Permalink to this heading">¶</a></h3>
<p>At present, Scheme for Max provides new facilities to Max, but does not integrate
with other Max extensions. As a result, many users who would benefit from S4M are
not aware of its capabilities - it is the kind of thing they need to find on their own.
A notable item of planned work that will adress this is implementing an integration with the Bach project.</p>
<p>Bach (the Bach Automated Composer’s Helper) is a long-standing open-source (TODO first release)
project that provides Max patching objects for accomplishing computer-assisted composition
tasks similar to those available in Lisp-based platforms such as Patchworks and OpusMondi (CITE).
Bach does this by supporting what the project calls lllls (Lisp-like linked lists), a high-level
data type corresponding to the Lisp list in its ability to nest and to hold heterogenous data.
In addition, the Bach project, and its extensions such as Cage and Dada, provide
a wide variety of objects for working with these lists, including sophisticated graphical
elements such as score representations and piano rolls.
Bach uses lllls in a similar fashion to how Max uses dictionaires
and S4M uses s4m-arrays: the data is stored in a global Bach-controlled registry,
and objects can pass references to these between them.
However, while being inspired by Lisp data structures and Lisp-based platforms,
Bach is notably missing an interactive Lisp interpreter itself.
Were Scheme for Max also able to work with lllls, the capabilities of both Bach
and S4M would be significantly increased, and the number of users interested in Scheme
for Max would likely also increase significantly.</p>
<p>One of the first major initiatives planned for post-1.0 S4M development is
developing an integration layer for Bach, and I have met with one (TODO NAME) of the
Bach developers to discuss plans already.</p>
</section>
<section id="real-time-scheduling">
<h3>Real-time Scheduling<a class="headerlink" href="#real-time-scheduling" title="Permalink to this heading">¶</a></h3>
<p>As previously mentioned, there is an issue that manifests itself when programs
making particularly large numbers of delay calls are run for long periods, while
the computer is also doing significant other work (e.g., rendering audio in plugins).
This manifested itself on my system only after I began working on pieces in Ableton
Live in which 16 different Scheme sequencers were running concurrently, each
making a new call to delay on each 16th note (thus producing on the order of 100 delay
calls per second, depending on the tempo).
After some period of time of running without a reset of the interpreter, such as 15 minutes or
so, CPU use becomes to high for real-time rendering.
The behaviour is similar to what happens when the audio latency is too low or
the heap size is too high, both situations where the garbage collector cannot finish in time.
It thus seems likely (though at this point this is speculation) that the memory
over which the GC is running has inadvertenly grown, and there is a bug in my
implementation of the scheduled function callback handling that prevents the garbage
collection of already scheduled functions.
This is most serious limitation at the moment and is something on which I will be actively
working.</p>
</section>
<section id="garbage-collection">
<h3>Garbage Collection<a class="headerlink" href="#garbage-collection" title="Permalink to this heading">¶</a></h3>
<p>In addition to the bug in my implementation, there is the fact that the s7 garbage
collector is not designed for real-time use. There has been significant work
in recent years on garbage collection algorithms, including the development
of incremental gargage collectors. An incremental collector does not finish
all its work on every pass, and would likely perform better in an audio situation
as the work can be distributed over time. Audio computation is, by its nature,
“bursty”, with much work happening during the computation of the audio block
corresponding to times with many note onsets. Allowing the gc to leave unfinished
business until a subsequent pass thus has the potentially of significantly lowering
the latency at which Scheme for Max can be used.
This, however, will require significant development work, and is thus currently
only a potential, and long-term, area of exploration.</p>
</section>
<section id="thread-limitations">
<h3>Thread Limitations<a class="headerlink" href="#thread-limitations" title="Permalink to this heading">¶</a></h3>
<p>At present, the user can choose between running the s4m object in the
low-priority main thread or high-priority scheduler thread, but cannot
run the interpreter in the audio thread.
Were it possible to run an instance in the audio thread, s4m could be
used to produce audio signals at single sample temporal accuracy.
This could be useful for those wishing to sequence synthesizer controlled
by control voltages, as this is done in modern audio workstations by outputing
control voltage signals as audio streams.
While Scheme, as a high-level language with a garbage collector, is unlikely
to be appropriate for heavy digital signal processing, control voltage
signals do not necessarily need to be created at the same bit-depth or
sample rate as regular audio. For example, in the Csound language,
it is common to use <em>k-rate</em> signals, generated at a divisor of the sample
rate, to control many attributes of synthesis. (CITE) It is thus possible that creating
control rate signals for purposes such as gates (controlling note onsets),
envelopes, and low frequency oscillators could all be practical Scheme.</p>
<p>This would require creating a variant of the Scheme for Max object that would
run the Scheme interpreter within the audio rendering function
and use some form of thread-safe queuing to pass Max messages in and out to the
scheduler thread.
It is likely that this would be more practical when used in conjuction with
an incremental garbage collector.
While control rate signals generated from Scheme are unlikely to be possible
with the same latency as those generated from C (given the unavoidable extra
computation), the convenience of doing so may well make the endeavour worthwhile,
especially as computers continue to become faster.</p>
<p>Running in the audio thread could also make it possible to create objects
that combine Scheme for Max and other audio systems in one Max object.
This could be used, for example, to create a Scheme-capable Csound object,
in which Scheme functions that directly access the Csound API could interact
with Csound at a deeper and more temporally accurate level than is currently possible
with the scenario of a separate s4m and csound~ object, communicating via
Max messages in the scheduler thread.</p>
</section>
<section id="difficulty-of-extension">
<h3>Difficulty of Extension<a class="headerlink" href="#difficulty-of-extension" title="Permalink to this heading">¶</a></h3>
<p>Scheme for Max is open source software, licensed under the permissive BSD license,
enabling any one to extend it if desired.
This is potentially attractive to users who would like to integrate Scheme code
with processes that will be much faster to execute in C.
The s7 foreign function interface makes this quite straightforward - it does not
require much in the way of code to add a C function that can be called from
Scheme - and this was indeed one of the motivations for choosing s7.
However, the programming logistics around doing so are prohibitively cumbersome:
one must go through all the setup necessary to create a Max extension with the
Max SDK, and one must also navigate and alter the main s4m.c file.</p>
<p>A potential area of work to address this would be the creation of plugin system
or automated compilation system for Scheme for Max extensions.
This could even use other languages that compile to C, such as Zig or OCaml.
While I feel this would be a very powerful additional piece of functionality,
the target user base for this feature is likely very small.
This is thus a long-term potential area of exploration.</p>
</section>
</section>
<section id="conclusion">
<h2>Conclusion<a class="headerlink" href="#conclusion" title="Permalink to this heading">¶</a></h2>
<ul class="simple">
<li><p>scheduling bug</p></li>
<li><p>no realtime gc</p></li>
<li><p>does not run in audio thread</p></li>
<li><p>hard to extend</p></li>
</ul>
</section>
<section id="conlusion">
<h2>Conlusion<a class="headerlink" href="#conlusion" title="Permalink to this heading">¶</a></h2>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">M.Tech Thesis</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction - TODO</a></li>
<li class="toctree-l1"><a class="reference internal" href="background.html">Background - Computer Music Programming Languages (4300 words)</a></li>
<li class="toctree-l1"><a class="reference internal" href="goals.html">Project Goals and Motivation - 1500 words</a></li>
<li class="toctree-l1"><a class="reference internal" href="design.html">High-Level Design (4775 words)</a></li>
<li class="toctree-l1"><a class="reference internal" href="features_usage.html">Features and Usage  (6300 words)</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Conclusion - IN PROGRESS (2948 w)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#evaluation">Evaluation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#be-focused-on-programming-musical-events-and-event-oriented-tools-rather-than-audio">#. Be focused on programming musical events and event oriented tools, rather than audio</a></li>
<li class="toctree-l3"><a class="reference internal" href="#support-multiple-contexts-scored-composition-realtime-interaction-and-live-performance">#. Support multiple contexts: scored composition, realtime interaction, and live performance</a></li>
<li class="toctree-l3"><a class="reference internal" href="#support-advanced-functional-and-object-oriented-programming-techniques-for-implementing-complex-algorithms">#. Support advanced functional and object-oriented programming techniques for implementing complex algorithms</a></li>
<li class="toctree-l3"><a class="reference internal" href="#be-linguistically-optimized-for-the-target-use-cases">#. Be linguistically optimized for the target use cases</a></li>
<li class="toctree-l3"><a class="reference internal" href="#be-usable-in-conjunction-with-modern-commercial-tools">#. Be usable in conjunction with modern, commercial tools</a></li>
<li class="toctree-l3"><a class="reference internal" href="#support-composing-music-that-is-impractical-on-commercial-tools">#. Support composing music that is impractical on commercial tools</a></li>
<li class="toctree-l3"><a class="reference internal" href="#enable-interactive-development-during-musical-playback">#. Enable interactive development during musical playback</a></li>
<li class="toctree-l3"><a class="reference internal" href="#evaluation-summary">Evaluation Summary</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#limitations-and-future-work">Limitations and Future Work</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#limited-integrations">Limited Integrations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#real-time-scheduling">Real-time Scheduling</a></li>
<li class="toctree-l3"><a class="reference internal" href="#garbage-collection">Garbage Collection</a></li>
<li class="toctree-l3"><a class="reference internal" href="#thread-limitations">Thread Limitations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#difficulty-of-extension">Difficulty of Extension</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#conclusion">Conclusion</a></li>
<li class="toctree-l2"><a class="reference internal" href="#conlusion">Conlusion</a></li>
</ul>
</li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="features_usage.html" title="previous chapter">Features and Usage  (6300 words)</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, Iain C. T. Duncan.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.2.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/conclusion.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>