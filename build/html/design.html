
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>High-Level Design &#8212; M.Tech Thesis  documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Features and Usage" href="features_usage.html" />
    <link rel="prev" title="Project Motivation and Goals" href="goals.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="high-level-design">
<h1>High-Level Design<a class="headerlink" href="#high-level-design" title="Permalink to this heading">¶</a></h1>
<p>In this chapter I will discuss the design of Scheme for Max on a high level
and the rationale for the various design decisions, in light of the previously discussed goals.</p>
<section id="why-a-max-extension">
<h2>Why a Max extension?<a class="headerlink" href="#why-a-max-extension" title="Permalink to this heading">¶</a></h2>
<p>As discussed, Scheme for Max is a tool for multi-language computer music programming. This begs
the first design question: “Why choose Max specifically as the host platform?”.</p>
<p>One driver for choosing Max is the success of Max itself.
Having been first created in the 1980’s, Max is now one of the most popular platforms world-wide
for making computer music, with thousands of Max objects available between those provided by Cycling 74 and
the broader Max community (CTN: maxobjects.com 2023).
This extensive community and breadth of available objects enables a wide variety of ways of working
with both musical abstractions and digital audio, and even video.
This includes support for interacting with external hardware through various synchronization and
message protocols and hosting commercial software synthesizers and effect plugins in Max itself through
the vst~ object.</p>
<p>In addition to being a popular and powerful platform on its own, Max has been available since 2009 as “Max for Live”,
an embedded runtime within the widely adopted commercial audio workstation and sequencing platform, “Ableton Live”
(CTN: Ableton 2009).
Max for Live has been so successful as an addition to Live that it led to Ableton aquiring Cycling 74 in 2017
(CTN: Ableton 2017).
When run in Max for Live, Max patches are able to processing both audio
and MIDI data, can also interact with the host through an application programming interface, the Live API.
The Live API provides Max patches the ability to control and query the Live engine, read and write to
Live’s own sequence and audio data, interact with the mixer and effects, and interact with the global transport.
Max for Live is included automatically in the top-tier Ableton offering (“Live Suite”) as well as via an add-on to Live.
While exact numbers are not published by Ableton, it seems highly likely that, between the standalone Max
version and Max for Live, Max has become the most widely deployed advanced computer music programming platform worldwide.</p>
<p>In addition to the popularity of the platform and its integrations with a full-featured commercial sequencing tool,
there are implementation related attractions to Max as well.
Max supports two kinds of data passed between objects, audio samples and event messages, which in turn run in several
different threads of execution.
In Max, there are actually two threads handling event messages, the “main thread” and the “scheduler thread”.
The first is also referred to as the UI thread, or low-priority thread, and the second as the high-priority thread.
MIDI data, events from timers and metronomes, and events from audio signals that have been turned into event messages
(with various translation objects) all use the high-priority scheduler thread.
Events from the user interacting with the GUI run in the low-priority thread, which is also used for redrawing any UI widgets.
A Max external can run in any or all of these contexts, and various objects and functions exist to pass events from one to the other
(CTN: Cycling 74 2019).</p>
<p>Scheme for Max operates only in the two event oriented threads, receiving and producing only Max messages -
that is, it does not render blocks of samples in the audio thread.
It can optionally be run in <em>either</em> the low or high priority thread, but each instantiation of the s4m object
is limited to one of these (chosen at instantiation time).
The threading designs of Max and Scheme for Max make it possible for us to run Scheme for Max code only occasionally
(i.e, on receipt of a message rather than on every block of samples), and also to ensure that it runs at a high priority
and is not interrupted by low priority activity.</p>
<p>As a result, the choice of creating the project as an extension for Max supports several of the stated goals.
There is a clear distinction between event time and audio time, supporting the goal of focusing on
the musical event (e.g. “note”) abstraction level.
By running only at the event time scale, we are afforded the option to use a high-level, garbage-collected language -
whereas runing a garbage-collected language in the audio rendering loop would seriously limit the amount of
computation possible in real time and likely require us to run with a high degree of latency.</p>
<p>Additionally, using Max supports also the goal of being able to use the project in conjunction with modern commercial music tools.
Max runs seamlessly inside Ableton Live, and both Max and Live can host commercial VST plugins.
When run in Ableton Live, Max uses Live’s transport, and when run as a VST host, Max’s transport is visible to the VST plugins.
It is thus possible to create music that mixes algorithmic content generated in Scheme with
content that is sequenced, rendered, or recorded with commercial tools.</p>
<p>Finally, using Max supports the goal of being usable for real-time interaction and live performance.
The Max clocking facilities are highly accurate, with jitter being typically in the 0.5-1ms range when
using a typical signal vector size of 32 or 64 samples (CTN: Lyon 2006, 67).
(Signal vector size is user configurable in standalone Max, and is locked to 64 samples in Ableton Live.)
Max timers are also implemented such that this degree of jitter does not accumulate over time, something
I have verified in extensives tests during development.
This means we have a way to work with realtime events at levels of latency and temporal accuracy that
are appropriate for live performances with highly trained musicians.</p>
<p>Taken together, these three points makes Max a very attractive host platform for the project.
We can create music that is implemented in various mixes of Scheme, standard Max programming, and sequencing from Ableton Live.
We can use modern commercial effect and synthesis plugins, taking advantage of the dramatic advances in software synthesis in recent years.
And timing is reliable and accurate enough that we can use the tool on stage, or in the studio for commercial production of
music where high timing accuracy is desired (e.g. electronic dance music).
We can even, through Ableton Live, use the tool during the mixing and mastering processes, as all of this can be done in Live,
with Scheme for Max used to orchestrate and automate Live devices and VST plugins.</p>
<p>However, the advantages just discussed could be applied to any general purpose programming
language hosted in a Max external.
Which begs the second question: “Why use a Lisp dialect rather than something a more popular interpreted language as Python, Ruby,
JavaScript, or Lua?”
Or more pointedly, why bother at all, when Max provides already an object that embeds an interpreter for JavaScript in the form of
the <strong>js</strong> object?</p>
</section>
<section id="why-not-just-use-javascript">
<h2>Why not just use JavaScript?<a class="headerlink" href="#why-not-just-use-javascript" title="Permalink to this heading">¶</a></h2>
<p>I will discuss in some depth the linguistic reasons for choosing a Lisp language, but first I will outline the
reasons I could not simply use the built-in js object to satisfy the project goals.</p>
<p>At first glance, the js objects seems like a comprehensive solution.
It runs in Max, it can send and receive Max messages, it has access to Max global data structures such as tables and buffers,
and it has a scheduler facility in the Task object (Taylor 2020).
Linguistically, it’s a high-level language with various modern features such as automatic memory management,
objects, lexical scoping, and functional programming techiques such as closures, and it is now one of the most popular
languages in the world (Sun 2017).</p>
<p>Unfortunately, the js object in Max has a serious implementation issue - in current versions of Max it <em>only</em> executes in the
lower-priority main thread.  Any messages sent to the js object from the scheduler thread are implicity queued to the
main thread and handled on its next pass (CTN: docs.cycling74.com n.d.).
The upshot of this is that the short-term timing of events handled in the js object is not reliable -
depending on other activity, execution of messages can be delayed, with this delay large enough to be audibly noticeable as errors.
While JavaScript is usable for a great many tasks in Max, realtime programmatic note triggering is not one of them.
This was simple for me to verify, as any heavy redrawing of the graphic layer (such as by resizing the window) will
introduce significant delays to tasks scheduled through the Max JavaScript Task object.</p>
<p>In fact, I began my work combining textual programming with the Max environment by attempting to use the js object
to build large-scale sequencing projects.
Overcoming the timing limitations of the js object was one of the initial motivations for the Scheme for Max project.
Fortunately, there is nothing in the Max SDK (the C and C++ software development kit used for building Max extensions) that requires
one to use any particular thread, thus any high-level language with an interpreter that is available as C or C++ code
can be used in the scheduler thread safely so long as messages coming from other threads are appropriately queued.</p>
</section>
<section id="why-use-a-lisp-language">
<h2>Why use a Lisp language?<a class="headerlink" href="#why-use-a-lisp-language" title="Permalink to this heading">¶</a></h2>
<p>Given that using the js object was not deemed satisfactory, the next design question becomes:
which choose a Lisp language?
For the purposes of this dicussion I will use “Lisp” when referring to traits shared across the Lisp family of languages
(including Scheme, Common Lisp, Clojure, and Racket), and Scheme when referring to the particular choice used in Scheme for Max.</p>
<p>In the initial research stage of this project (dating back to 2019) I examined various possible high-level languages,
and reviewed the use of many various general purpose languages in music.
Non-Lisp candidates I evaluated included Python, Lua, Ruby, Erlang, Haskell, OCaml, and JavaScript (i.e. in a new implementation).</p>
<p>Overall, I came to the conclusion that the advantages of working in a Lisp for music outweigh the disadvantages
of its relative unpopularity and its unfamiliar syntax (to most programmers today at least!).
These advantages include suitability for representing music; suitability for the typical scenarios and needs of the composer-programmer;
and suitability for implementing the project in Max specifically.</p>
<p>Compared to the other candidate languages mentioned, Lisps differ in several ways that are germane to this
discussion. (To be clear, some of these traits are shared by some of the other candidates, but I would argue that none of the
other candidates share all of these traits with Lisps.)</p>
<section id="symbolic-computation-and-list-processing">
<h3>Symbolic computation and list processing<a class="headerlink" href="#symbolic-computation-and-list-processing" title="Permalink to this heading">¶</a></h3>
<p>Lisp is unusual in its first-class support for programming with <em>symbols</em> and in its simple, minimal, and consistent syntax (CTN: Taube 2004, 8).
Programming with symbols, also known as “symbolic computation” or “symbolic processing”, means
that programs can work directly with not only program <em>data</em> but with the <em>textual tokens</em> comprising the program itself.
For example, as with any high-level language, we may have a variable named “foo”, at which we have stored the value 99,
allowing us to refer to the contents bound to that variable (99) by the name “foo”.
When the interpreter encounters the textual token “foo”, perhaps in an expression such as “1 + foo”,
it will automatically <em>evaluate</em> this token, replacing it in an internally expanded form with the number 99.
But in Lisp, we may also work with the textual token itself, referred to <em>the symbol foo</em>
just as easily as we work with any other primitive type. We can pass it around, put it in lists,
concatenate it to other symbols, and so on.
When we want to refer to the symbol part of a variable (the text to which the value is bound),
we use a facility of the language called <em>quoting</em>, by which we instruct the interpreter
to skip evaluating the symbol as a variable (thus expanding to 99) and instead work with the textual token.
We can quote by using the <strong>quote</strong> function, or by prepending a symbol with a single quote: <strong>‘foo</strong>.
This symbolic processing capability is particularly appropriate for music, as we shall see shortly.</p>
<p>In addition to this, Lisp syntax is <em>entirely</em> composed of s-expressions, which are parenthetical
expressions containing lists of symbols and primitives. We will see why this matters shortly.</p>
<p>For example, below are several ways to return a list of symbols. We can see that all
use one or more parenthetical expression as the basic unit of syntax.</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="c1">;; 3 ways of creating a list containing the symbols foo, bar, and baz</span><span class="w"></span>
<span class="c1">;; use the list function</span><span class="w"></span>
<span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="ss">&#39;foo</span><span class="w"> </span><span class="ss">&#39;bar</span><span class="w"> </span><span class="ss">&#39;baz</span><span class="p">)</span><span class="w"></span>
<span class="c1">;; quote the printed representation with a single quote</span><span class="w"></span>
<span class="o">&#39;</span><span class="p">(</span><span class="nv">foo</span><span class="w"> </span><span class="nv">bar</span><span class="w"> </span><span class="nv">baz</span><span class="p">)</span><span class="w"></span>
<span class="c1">;; use the quote function on the printed representation</span><span class="w"></span>
<span class="p">(</span><span class="k">quote</span><span class="w"> </span><span class="p">(</span><span class="nf">foo</span><span class="w"> </span><span class="nv">bar</span><span class="w"> </span><span class="nv">baz</span><span class="p">))</span><span class="w"></span>
</pre></div>
</div>
<p>The value returned by the above expressesions is represented on the console by the text <code class="docutils literal notranslate"><span class="pre">(foo</span> <span class="pre">bar</span> <span class="pre">baz)</span></code>.
Note that this looks idential to the source-code for a Lisp function call,
specifically it looks like code we would use to call the function <strong>foo</strong> with the arguments <strong>bar</strong> and <strong>baz</strong>.
And indeed, if we were to take the lists returned in our example and pass this returned <em>symbolic</em> structure
to the Lisp <strong>eval</strong> function,
that is exactly what would happen - the interpreter would execute whatever function is bound to the symbol <strong>foo</strong>, passing
it the arguments bar and baz.</p>
<p>Below is an example of doing just this at a Scheme interpreter. (The lines prefaced by <strong>&gt;</strong> are the text
responses from the interpreter that would be printed to a console in an interactive session.)</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="c1">; create a list and save it to the variable my-program</span><span class="w"></span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="nv">my-program</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="ss">&#39;print</span><span class="w"> </span><span class="mi">99</span><span class="p">))</span><span class="w"></span>
<span class="nb">&gt;</span><span class="w"> </span><span class="nv">my-program</span><span class="w"></span>
<span class="c1">; now run it, which will print 99</span><span class="w"></span>
<span class="p">(</span><span class="nb">eval</span><span class="w"> </span><span class="nv">my-program</span><span class="p">)</span><span class="w"></span>
<span class="nb">&gt;</span><span class="w"> </span><span class="mi">99</span><span class="w"></span>
<span class="c1">; or all in one step</span><span class="w"></span>
<span class="p">(</span><span class="nb">eval</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="ss">&#39;print</span><span class="w"> </span><span class="mi">99</span><span class="p">))</span><span class="w"></span>
<span class="nb">&gt;</span><span class="w"> </span><span class="mi">99</span><span class="w"></span>
</pre></div>
</div>
<p>In the example above, we used quoting to create
a list consisting of the symbol <strong>‘print</strong> and the number 99, and then
we used <strong>eval</strong> to <em>run this list as a program</em>.
The impact of this is profound:
Lisps allow us to easily and elegantly make programs that build lists of symbols and primitives,
<em>and these lists we have built can themselves be executed as programs</em>.</p>
<p>Now to be clear, we can also build a program with a program in other high-level languages, including Python, Ruby, Lua, and JavaScript.
However, in none of these languages is programming <em>on</em> the symbolic tokens of the language directly supported the way it is in Lisp.
The result is that in these other language this kind of dynamic programming (also known as “meta-programming”) is very involved and
typically seen as something to be used only sparingly by expert programmers building reusable tools.
In Lisp, on the other hand, manipulating lists of symbols, and later evaluating them as functions, is the very stuff of which the langauge is made.</p>
<p>Now, why does this matter for a programming language for music?</p>
<p>As in Lisp code, in music we use lists of symbols to represent functions, relationships, and events.
For example, let us say I write a chord progression, such as <strong>I vi ii V7</strong>.
We have a <em>list</em> of four items, each denoted by a symbol: <strong>I</strong>, <strong>vi</strong>, etc.
Each of these symbols represents musical data for a given chord, but by themselves, they don’t represent <em>music</em> -
they need a key <em>to which the function represented by the chord symbol can be applied</em>.
Thinking computationally, <strong>V7</strong> must be a <em>function</em> - it is a description of something we get when we apply a
particular algorithm (the intervals within the chord along with the scale-step for the root) to a parameter (the tonic key).</p>
<p>In a Lisp language, this can be represented in code that is visually compatible (almost identical even) to what we would use in musical analysis.
<code class="docutils literal notranslate"><span class="pre">(chords-&gt;notes</span> <span class="pre">'C</span> <span class="pre">'(I</span> <span class="pre">vi</span> <span class="pre">ii</span> <span class="pre">V7))</span></code> is a legitimate line of Lisp syntax that could be implemented to be a function
that renders a chord progression into a list of notes, given a tonic of C.
It could even return something symbolic that looks very familiar to a musician, and <em>on which more of the program can work</em>.
A potential return value could be represented by the interactive Lisp interpreter as a nested list containing sublists of symbols:
<code class="docutils literal notranslate"><span class="pre">'(</span> <span class="pre">(C</span> <span class="pre">E</span> <span class="pre">G)</span> <span class="pre">(A</span> <span class="pre">C</span> <span class="pre">E)</span> <span class="pre">(D</span> <span class="pre">F</span> <span class="pre">A)</span> <span class="pre">(G</span> <span class="pre">B</span> <span class="pre">D</span> <span class="pre">F))</span></code></p>
<p>Further, because this form of symbolic computation is so central to the language - one of the classic texts is even subtitled
“A Gentle Introduction to Symbolic Computation” - Lisps include numerous functions for manipulating and transforming lists (CTN: Touretzky 1984).
For example, we might transpose a list by applying a transposition function, which itself might be built by a function-building function
called <strong>make-transposer</strong>, and we might apply this function to a list of symbols.
This sounds complicated, and indeed, expressing this in most languages is cumbersome, but in Scheme this is both readable and succint:</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="c1">; apply a transposition function that transposes all elements in our chord progression by 2 steps</span><span class="w"></span>
<span class="c1">; the map function maps a function over a list, returning a new list</span><span class="w"></span>
<span class="c1">; (make-transposer 2) creates a function that transposes by 2 specifically</span><span class="w"></span>
<span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="nf">make-transposer</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="o">&#39;</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="nf">C</span><span class="w"> </span><span class="nv">E</span><span class="w"> </span><span class="nv">G</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">A</span><span class="w"> </span><span class="nv">C</span><span class="w"> </span><span class="nv">E</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">D</span><span class="w"> </span><span class="nv">F</span><span class="w"> </span><span class="nv">A</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">G</span><span class="w"> </span><span class="nv">B</span><span class="w"> </span><span class="nv">D</span><span class="w"> </span><span class="nv">F</span><span class="p">)))</span><span class="w"></span>

<span class="c1">; expressed without first expanding our chord progression</span><span class="w"></span>
<span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="nf">make-transposer</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="nf">chords-&gt;notes</span><span class="w"> </span><span class="ss">&#39;C</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">I</span><span class="w"> </span><span class="nv">vi</span><span class="w"> </span><span class="nv">ii</span><span class="w"> </span><span class="nv">V7</span><span class="p">)))</span><span class="w"></span>
</pre></div>
</div>
<p>This demonstrates thats Lisps are particularly well-suited to expressing musical data, relationships, and algorithms in
computer code, and a result of this suitability, there is a rich history of Lisp use in musical programming.
Examples of Lisp-based musical programming environments abound, both historical and current. In addition
to those already mentioned (Common Music and Nyquist), others include
Common Lisp Music, Common Music Notation, MIDI-Lisp, PatchWork, OpenMusic, cl-collider, and many more (CTN: CLiki n.d.).</p>
<p>Thus the choice of Scheme as the language for the project has several important advantages:</p>
<ul class="simple">
<li><p>Code representing musical data can be more succint, lowering the sheer amount of code the composer must contend with while working.</p></li>
<li><p>Code working with musical constructs can look remarkably similar to the notation that composers are used to, making the code
more readable, and thus more appropriate for use within a piece of music that may be composed of both data and code.</p></li>
<li><p>Programmers have access to a rich historical body of prior work, with code that can be ported to Scheme for Max relatively easily.</p></li>
</ul>
</section>
<section id="dynamic-code-loading-and-the-repl">
<h3>Dynamic code loading and the REPL<a class="headerlink" href="#dynamic-code-loading-and-the-repl" title="Permalink to this heading">¶</a></h3>
<p>Previously mentioned as interactive development, or REPL-driven development, Lisp programmers commonly work in an ongoing process
of evaluating new code in the interpreter and examining the interpreter’s output, <em>while the program runs</em>.
At any point, the programmer can send new expressions to the Lisp interpreter, which evaluates the expressions, updates
the state of the Lisp environment, and then prints the return value of evaluating the expressions.
These expressions can define new functions, redefine functions already in use, change state data, or
interactively inspect or alter the current environment. While this iteractive style of development is possible
to some degrees in other high level languages (such as Python and Ruby), it has been available to a deeper degree in Lisp going
back as far as the the 1970’s! (CTN: Sandewell 1978, 35-39)</p>
<p>For example, the composer-programmer might separate work into files that contain score data and files
that contain functions for altering or creating music, where the functions might be musical transformations of
algorithms for generating new content given base score data.
The files of functions can be incrementally edited and reloaded, thus updating algorithm definitions, without needing
to restart the piece or reset the score data.</p>
<p>In Scheme for Max, the programmer can also trigger
interpreter calls from text interface objects in Max, or even from an external text editor
by sending blocks of code over the local network into Max.
Max has a console window to show messages from the Max engine, and this is used by Scheme for Max
for the Print stage of the REPL loop so that the results of dynamic evaluation can be read by the programmer.</p>
<p>I have personally found this capability to be enormously productive while working on
algorithmically generated or augmented compositions - the ability to tinker with the algorithms
without necessarily restarting a piece is a signficant time saver, and being able to interactively
inspect data in the Max console while doing so is similarly helpful.</p>
</section>
<section id="macros-and-domain-specific-languages">
<h3>Macros and Domain Specific Languages<a class="headerlink" href="#macros-and-domain-specific-languages" title="Permalink to this heading">¶</a></h3>
<p>One of the hallmarks of Lisp is the Lisp macro.
We have previous discussed the ease with which the Lisp programmer can programmatically create lists of
symbols that are then evaluated as syntactic Lisp expressions; the Lisp macro is a linguistic formalization of this process.
In use, a macros look to the programmer just like a regular function call, but by virtue of being defined as a macro,
they are first called in a special evaluation pass known as the macro-expansion pass.
This runs the code in the body of the macro over the <em>symbolic arguments</em> passed in to it, returning a
programmatically created list structure (the macro-expansion) that is then evaluated.
Essentially, macros are code blocks that execute twice - first to build the code, then to evaluate it - though
technically they can be nested to repeat the expansion step an arbitrary number of times (CTN: Touretsky 1984, 405-417).</p>
<p>Macros enable programmers to create their <em>own</em> domain specific languages -
miniature languages within a language that are closer in syntax and sematics to the problem domain than to the host languauge.
This makes it possible for code that uses the macros (the “domain code”) to be visually aligned with the problem domain,
making them easier to read and faster to type.
For example, a macro I use for scheduling events in a score looks like the below:</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">score</span><span class="w"></span>
<span class="w">  </span><span class="nv">:1:1</span><span class="w">       </span><span class="p">(</span><span class="nf">phrase-a</span><span class="w"> </span><span class="nv">:dur</span><span class="w"> </span><span class="nv">2b</span><span class="w"> </span><span class="nv">:repeat</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="nv">:+8</span><span class="w">        </span><span class="p">(</span><span class="nf">phrase-b</span><span class="w"> </span><span class="nv">:dur</span><span class="w"> </span><span class="nv">8b</span><span class="w"> </span><span class="nv">:repeat</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="nv">:9:1:120</span><span class="w">   </span><span class="p">(</span><span class="o">..</span><span class="nv">etc</span><span class="p">))</span><span class="w"></span>
</pre></div>
</div>
<p>The time argument, <code class="docutils literal notranslate"><span class="pre">:1:1</span></code>, <code class="docutils literal notranslate"><span class="pre">:+8</span></code>, and <code class="docutils literal notranslate"><span class="pre">:9:1:120</span></code> are converted by the macro layer into musically meaningful time
representations, allowing the visual representation of the score code to be more easily read by the composer.
The flexibility of macros allow me to use textual representations that are convenient for me as the composer.</p>
<p>But to clarify, this is <em>not</em> a separate score language with limited functionality, as is found in Csound.
This <em>is Scheme code</em> - it can include <em>any</em> Scheme functions and even be built by Scheme functions.
Thus the use of a language with macro facilities enables the composer to work with different kinds of code
- function defining code and score code - in one language, without giving up the expressive power of high-level language
facilities. This use of a general programming language that can function additionally <em>as a readable score language</em>
provides tremendous flexibility to the programmer, breaking the dichotomy between score data and running program  (CTN: Dannenberg 1997, 50-60).</p>
</section>
<section id="max-and-lisp-syntax-compability">
<h3>Max and Lisp syntax compability<a class="headerlink" href="#max-and-lisp-syntax-compability" title="Permalink to this heading">¶</a></h3>
<p>Finally, there is the fortunate coincidence of the Max message syntax being almost perfectly compatible with Lisp syntax.
This happy accident (we can assume!) means that a composer-programmer can create and run Scheme code <em>in Max messages</em>, and
use Max message-building functions to do so.
While this compatibility was not something I was expecting when originally embarking on the design of Scheme for Max,
it has had a profound effect on the ease with which one can build Max patches that interact with Scheme for Max programs.</p>
<p>A Max message consists of Max <em>atoms</em>, which are space-separated tokens that may be integers, floating point numbers, or alpha-numeric symbols.
It may also consist of several special characters: the dollar sign, the comma, and the semi-colon.
The dollar sign is used as a template interpolation symbol: messages with dollar signs in their text body will output template
explansions to downstream objects, injecting arguments they receive in their inlets.
A leading semi-colon in a Max message indicates the message is a special message sent to the Max engine itself.
Finally, the comma is used to indicate that the message is actually two message, with the two comma-separated halves being sent sequentially.</p>
<p>Notably, the parenthesis, used in Lisp to delimit Lisp expressions, and the colon, used to indicate that a symbol should be a keyword (a special kind of symbol),
have no special significance in Max messages.
Conversely, the dollar sign has no significance in Lisp, and the semi-colon (used for comment characters) and the comma
(used for back-quote escaping) are easily avoided.</p>
<p>The result of this is that rather than require the programmer to create special handlers in their code to respond to Max messages,
as one must do when using the js object, the s4m object is able to simply evaluate incoming messages <em>as if they were Scheme code</em>,
saving the programmer the need to write callback functions for every type of incoming message.
This facility is covered in more detail in the Features and Usage chapter, with an accompanying figure.</p>
<p>Having built some complex programs myself in JavaScript in Max prior to building Scheme for Max,
I have found this to be a significant advantage of Scheme for Max over the js object.</p>
</section>
</section>
<section id="of-the-possible-lisp-languages-why-use-s7-scheme">
<h2>Of the possible Lisp languages, why use s7 Scheme?<a class="headerlink" href="#of-the-possible-lisp-languages-why-use-s7-scheme" title="Permalink to this heading">¶</a></h2>
<p>When beginning the project, after determining that a Lisp-family language was appopriate, I evaluated a number of
Scheme and Lisp implementations as candidates.
I will discuss now why the s7 implementation in particular was chosen.
(Note for the curious: the author has informed me that s7 is intended to be spelled lowercase
as it is named after a Yamaha motorcycle!)</p>
<section id="use-in-computer-music">
<h3>Use in Computer Music<a class="headerlink" href="#use-in-computer-music" title="Permalink to this heading">¶</a></h3>
<p>s7 was created by, and is maintained by, Bill Schottstaedt, a professor emeritus of the Stanford music centre (CCRMA),
and the author of Common Lisp Music and the Snd editor.
s7 is used in in Snd editor (essentially an Emacs-like audio editing tool), and in Common Music 3, an algorithmic composition
platform created by Henrik Taube (Schottstaedt n.d.).
This has meant that there is a significant body of code from Common Music that can be used with very minimal adjustment in Scheme for Max.
Indeed, if I were to describe S4M in one sentence, it would be that it is a cross between Common Music and the Max js object.</p>
</section>
<section id="linguistic-features">
<h3>Linguistic Features<a class="headerlink" href="#linguistic-features" title="Permalink to this heading">¶</a></h3>
<p>Not suprising, given the author’s involvement with Common Lisp (CL) music systems, s7 is, by Scheme standards,
highly influenced by Common Lisp.
It includes Common Lisp <em>keywords</em>, which are symbols that begin with and always evaluate to themselves.
s7 also uses Common Lisp style macros (a.k.a. “defmacro” macros), rather than the syntax-case or syntax-rules macros
in many other Scheme implementations.
To support CL macros safely (without inadvertent variable capture), s7 includes support for first-class environments
(lexical environments that can be used as values for variables), and the “gensym” function, which is used to create
guaranteed-unique symbols for use in a macroexpansion (Schottstaedt n.d.).
Interestingly, and perhaps fortunately for the purpose of adoption, these are features also shared with Clojure,
a modern Lisp variant with much in common with Scheme, and with wide use in business and web application circles
(Miller et al. 2018).</p>
<p>We can assume these features were chosen by Bill as appropriate for his use case - the solo composer-programmer -
and indeed in my personal experience they have been helpful for working on projects in S4M.
For example, the ability to use keywords allows us to have symbols in Max messages that will be preserved
as symbols when the message is evaluated by the s4m interpreter, and these are easily differentiated visually in Max messages.</p>
</section>
<section id="ease-of-embedding">
<h3>Ease of embedding<a class="headerlink" href="#ease-of-embedding" title="Permalink to this heading">¶</a></h3>
<p>Of the Lisp dialects, Scheme in particular has a further pragmatic advantage.
Due to its minimal nature, it is eminently appropriate for embedding in another language,
and there thus exists a wide variety of embeddable Scheme intepreters.
A functional Scheme interpreter can be created in a very small amount of code -
there is even an implementation named SIOD, for “Scheme In One Defun” (but also referred to as “Scheme in One Day”).
SIOD was a project by computer science professor George Carrette, started in 1988, intended to make
the smallest possible Scheme interpreter that could be embedded in a C or C++ program (CTN: Carrette 2007).</p>
<p>The s7 project in particular is a Scheme distribution intended expressly for embedding in C host programs, and
designed to make that use case as simple as possible.
The core s7 interpreter is distributed as only two files, s7.h and s7.c, that can simply be included in a source tree.
The foreign function interface (FFI) is very straightforward, making adding Scheme functions to S4M simple.
And, importantly, s7 is fully thread-safe and re-entrant - meaning that there is no issue having multiple, isolated s7 interpreters
running in the same application, a situation common in a Max patch where many s4m object may coexist, but a feature
not common across all candidate implementations (CTN: Schottstaedt n.d.).</p>
</section>
<section id="license">
<h3>License<a class="headerlink" href="#license" title="Permalink to this heading">¶</a></h3>
<p>Finally, s7 uses the BSD license, a permissive free software license.
The BSD license imposes no redistribution restrictions the way the GPL family of licenses do, thus user-developers wishing to
use s7 in a commercial project are free to do so with no obligations (CTN: Schottstaedt n.d.).</p>
<p>This is a point in s7’s favour as many Ableton Live device developers sell devices, and many Max developers sell standalone Max
applications, thus I would also like to allow use of S4M in these contexts.</p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">M.Tech Thesis</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="background.html">Background - Computer Music Programming Languages</a></li>
<li class="toctree-l1"><a class="reference internal" href="goals.html">Project Motivation and Goals</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">High-Level Design</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#why-a-max-extension">Why a Max extension?</a></li>
<li class="toctree-l2"><a class="reference internal" href="#why-not-just-use-javascript">Why not just use JavaScript?</a></li>
<li class="toctree-l2"><a class="reference internal" href="#why-use-a-lisp-language">Why use a Lisp language?</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#symbolic-computation-and-list-processing">Symbolic computation and list processing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dynamic-code-loading-and-the-repl">Dynamic code loading and the REPL</a></li>
<li class="toctree-l3"><a class="reference internal" href="#macros-and-domain-specific-languages">Macros and Domain Specific Languages</a></li>
<li class="toctree-l3"><a class="reference internal" href="#max-and-lisp-syntax-compability">Max and Lisp syntax compability</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#of-the-possible-lisp-languages-why-use-s7-scheme">Of the possible Lisp languages, why use s7 Scheme?</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#use-in-computer-music">Use in Computer Music</a></li>
<li class="toctree-l3"><a class="reference internal" href="#linguistic-features">Linguistic Features</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ease-of-embedding">Ease of embedding</a></li>
<li class="toctree-l3"><a class="reference internal" href="#license">License</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="features_usage.html">Features and Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="conclusion.html">Conclusion</a></li>
<li class="toctree-l1"><a class="reference internal" href="bibliography.html">References</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="goals.html" title="previous chapter">Project Motivation and Goals</a></li>
      <li>Next: <a href="features_usage.html" title="next chapter">Features and Usage</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, Iain C. T. Duncan.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.2.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/design.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>