{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf600
{\fonttbl\f0\fnil\fcharset0 Lato-Regular;}
{\colortbl;\red255\green255\blue255;\red35\green37\blue41;\red255\green255\blue255;}
{\*\expandedcolortbl;;\cssrgb\c18039\c19216\c21176;\cssrgb\c100000\c100000\c100000;}
\deftab720
\pard\pardeftab720\sl312\slmult1\slminimum320\partightenfactor0

\f0\fs26 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 In order to understand the role filled by Scheme for Max, it is necessary for us to understand in some detail the Max music programming environment in which it runs. \
\
Max, previously named Max/MSP, is the predominant visual programming environment for creating interactive multi-media in music academia, as well as in commercial music circles through "Max for Live", an extension to the Ableton Live digital audio workstation embedding Max in Ableton Live. Created originally by Miller Puckette in \{year\} while working at IRCAM, Max was designed to enable composers of interactive computer music to change their pieces without needing the assistance of a programmer. Max programs ("patches" in the Max nomenclature) are created by placing visual objects on a canvas ("the patcher"), and connecting them in a graph with visual "patch cords". Patches execute by sending messages objects in the patcher in a data-flow execution model, whereby a message from one object (the source) triggers execution in one or more receiving objects, who in turn send on messages to further objects. Patch execution can be triggered by various forms of real-time input (e.g.  keyboard or mouse events, MIDI input,  networking events) or scheduled events (e.g. through the \'93metronome\'94 object) which produce Max messages that are sent from their input source objects on to the rest of the patcher.  Messages are represented visually as lists of Max atoms, which may be symbols, integers, and floating point numbers.  Messages can be constructed either by the objects that send them, or directly by the programmer using "message" objects. Execution follows a depth first and right-to-left order, enabling the programmer to deterministically control the execution flow through the visual layout of the patch cords.  (i.e., A source object sending messages out to multiple receiving sub-graphs results in the righthand message path completing execution before moving left, rather than spawning two concurrent threads of execution.)\
\
In addition to the event-based message execution model, Max also supports a stream-based digital audio execution model. Objects with names ending in the tilde character are DSP handler objects (\'93MSP\'94 objects in Max nomenclature), and are connected to each other through special patch cords representing a constant flow of digital audio. \cf2 \cb3 \strokec2 Max objects internally are implemented to work either in the DSP execution context or the message execution context (indicated by the presence or absence of the tilde character in the object\'92s name), but  DSP objects may also receive messages for control.\cf2 \cb3 \strokec2 DSP objects may also respond to message input. For example, a gain~ object receives digital audio in its top \'93inlet\'94, passing it out the bottom \'93outlet\'94 after applying a multiplier for altering the signal amplitude;  a message sent to the right hand inlet of the gain~ object changes this multiplier.   S4M executes at the event level with Max messages and thus does not implement DSP operations, however some understanding of Max DSP operations will be necessary to understand the Max threading model and thus some of the advantages of S4M relative to existing scripting solutions.\
\
Max execution is spread across between 2 to 3 threads, depending on various configuration settings. In regular execution, there will be two threads for handling messages, and one for DSP. The message handling threads consist of one high-priority thread. Max may be run with audio output turned off, in which case the DSP thread does not execute. \
\
\
\
}