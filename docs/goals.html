
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Project Goals and Motivation - 1500 words &#8212; M.Tech Thesis  documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="High-Level Design (4775 words)" href="design.html" />
    <link rel="prev" title="Background - Computer Music Programming Languages (4300 words)" href="background.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="project-goals-and-motivation-1500-words">
<h1>Project Goals and Motivation - 1500 words<a class="headerlink" href="#project-goals-and-motivation-1500-words" title="Permalink to this heading">¶</a></h1>
<p>Status: -done, need proof read and citations(?)</p>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this heading">¶</a></h2>
<p>Scheme for Max is the result of many years of exploring computer music platforms for composing, producing,
and performing music.
The project requirements were born from my experiences, both positive and negative, with a wide variety of tools, both commercial and academic.
Broadly, the requirements I set myself for the project are that it should:</p>
<ol class="arabic simple">
<li><p>Be focused on programming musical events and event oriented tools, rather than audio</p></li>
<li><p>Support multiple contexts: scored composition, realtime interaction, and live performance</p></li>
<li><p>Support advanced functional and object-oriented programming techniques for implementing complex algorithms</p></li>
<li><p>Be linguistically optimized for the target use cases</p></li>
<li><p>Be usable in conjunction with modern, commercial tools</p></li>
<li><p>Support composing music that is impractical on commercial tools</p></li>
<li><p>Enable interactive development during musical playback</p></li>
</ol>
<p>These goals will act as our reference when discussing the sucess of design and implementation decisions.
I will discuss each briefly.</p>
</section>
<section id="focus-on-programming-musical-events-and-event-oriented-tools">
<h2>1) Focus on programming musical events and event-oriented tools<a class="headerlink" href="#focus-on-programming-musical-events-and-event-oriented-tools" title="Permalink to this heading">¶</a></h2>
<p>While many approaches to programming computer music exist, many domain specific computer music langauges are
designed principally around rendering audio streams, acting as higher level langauges for digital signal processing.
Examples of these include SuperCollider, Chuck, Faust, and to a lesser degree, Csound.
My goal for the project is rather to focus the design decisions around the programming of musical <em>events</em>, unencumbered by the need to also support DSP processes.
The intent is that the tool will be used in conjunction with other software that handles the lower level DSP activity,
whether this is by delegating to other programming languages (e.g. Max, Csound, Chuck, etc.)
or by sending messages to external audio producers through MIDI or OSC messages.
The decision not to have the tool itself handle DSP
significantly reduces the amount of ongoing computation, which provides linguistic possibilities.
The most notable being that use of higher-level, interpreted, and garbage-collected languages becomes potentially feasible.
I believe that reducing the scope in this way enables an approach that is much more efficient
for the specific act of composing from the composer-programmer’s perspective.</p>
</section>
<section id="support-multiple-contexts-scored-composition-realtime-interaction-and-live-performance">
<h2>2) Support multiple contexts: scored composition, realtime interaction, and live performance<a class="headerlink" href="#support-multiple-contexts-scored-composition-realtime-interaction-and-live-performance" title="Permalink to this heading">¶</a></h2>
<p>On modern computers, it is now possible to run complex computer music processes in real time, where “real time”
means there are not any audible audio issues from missed rendering deadlines, and the system can run with a
latency low enough for the user to interract with music with an immediacy appropriate to playing instruments (i.e. 5-20ms).
Meeting this goal thus implies that one can iteract with a composition built in the system while it plays,
and that an instrumentalist ought to be able to perform with objects created in the tool with a latency that allows accurate performances.
However, there also exist types of music where a predetermined score of great complexity is the most
appropriate tool, for example where this complexity may exceed the capabilities of human players.</p>
<p>Thus, the project should satisfy all of these criteria:
it should be usable to create entirely prescored pieces such as the piano etudes of Conlon Nancarrow,
where the score is so dense as to be unperformable by human players;
it should be usable in the studio to compose music that is developed through real-time interactions with
algorithmic processes and live-programmed tools such as sequencers;
and it should be usable on stage, for example to create performances in which a human being plays
physical instruments that interact with the program.</p>
</section>
<section id="support-advanced-functional-and-object-oriented-programming-techniques">
<h2>3) Support advanced functional and object-oriented programming techniques<a class="headerlink" href="#support-advanced-functional-and-object-oriented-programming-techniques" title="Permalink to this heading">¶</a></h2>
<p>The project should support advanced functional programming idioms, many of which are now in the broader
programming mainstream, having been adopted into mainstream languages such as JavaScript, Java, Python, and Ruby.
This could potentially include support for first-class functions, lexical closures,
message-passing object-orientation, tail recursion, higher-order types, continuations, and so on.
The support of these programming idioms ought to make it possible for programmer-composers to express
their intent more succinctly, with the code better representative of musical intent, and
also make the tool more attractive to advanced programmers who might otherwise
feel they need to use a general purpose language.</p>
</section>
<section id="be-linguistically-optimized-for-the-target-use-cases">
<h2>4) Be linguistically optimized for the target use cases<a class="headerlink" href="#be-linguistically-optimized-for-the-target-use-cases" title="Permalink to this heading">¶</a></h2>
<p>Support for higher level functional and object-oriented programming idioms can be done in a variety of
general programming languages, with the differences between these languages having ramifications on the development process.
All language design involves tradeoffs - what is most convenient for a small team of expert users early
in the process of development can be a hindrance for a large team of mixed expertise working on a very large code base.
Design of the project should take this into account.</p>
<p>Composers working on pieces are normally working solo or in very small teams.
The work of a composer typically consists of building many smaller projects (smaller relative to the size of a large
commercial code base that is), all of which are likely to build on some common set of tools and processes reused across pieces.
The linguistic design of the project should take this into account and be optimized for this scenario,
favouring whatever is most efficient for the process of composing and interacting with the system while the program runs.</p>
</section>
<section id="be-usable-in-conjunction-with-modern-commercial-tools">
<h2>5) Be usable in conjunction with modern, commercial tools<a class="headerlink" href="#be-usable-in-conjunction-with-modern-commercial-tools" title="Permalink to this heading">¶</a></h2>
<p>A common problem with many of the existing computer music DSLs is that they were designed with the
expectation that the user would be using only (or principally) the lanugage in question - that in effect,
the DSL would always get to “be the boss”.
For example, Common Music enables composing in a high-level language (Scheme), but to be used in real-time,
this Scheme code must be run from the Grace host application, where it uses the Grace scheduler for controlling event times.
There is no option to have the Common Music scheduler synchronize to an external clock, and thus combining
music coming from Common Music with musical elements coming from a commercial sequencing program such as
Ableton Live is not practical.
As commercial music software becomes more and more sophisticated, especially in the areas of sound design
and emulation of analog hardware, working in a platform that cannot support the use of commercial plugins
becomes less and less attractive to composers.
Thus a goal of the project is to ensure that, whatever its design, it lends itself well to composing and
producing in scenarios where some musical elements may originate from or stream to commercial tools such
as Ableton Live and modern VST plugins.
The user of the project should not be faced with a binary choice between using the power of the project or
having the convenience and audio quality of modern commercial tools available to them.</p>
</section>
<section id="support-composing-music-that-is-impractical-on-commercial-tools">
<h2>6) Support composing music that is impractical on commercial tools<a class="headerlink" href="#support-composing-music-that-is-impractical-on-commercial-tools" title="Permalink to this heading">¶</a></h2>
<p>While being able to work with commercial tools is a goal, this cannot be at the expense of supporting
compositions that are impractical on commercial platforms.
Naturally, commercial music tools are designed around the needs of the majority of users.
The visual and interface design of sequencers and workstations such as Ableton Live, Logic, and Reaper
make assumptions that do not stand up to many 20th century or new music practices.
For example: that there will be only one meter at a time, that meter will not change too frequently,
that the time scale of composition used across voices is similar, that the number of voices is not
in the thousands, that repeats signs and structure is the same across voices, and so on.
These design constraints are straightforward to loosen in a high-level textual language.</p>
</section>
<section id="enable-iterative-development-during-musical-playback">
<h2>7) Enable iterative development during musical playback<a class="headerlink" href="#enable-iterative-development-during-musical-playback" title="Permalink to this heading">¶</a></h2>
<p>Finally, a goal of the project is to ensure that all of the goals so far can be achieved in a way that
allows <em>interactive development</em> during audio playback.
Users of modern commercial tools on modern computers do not expect to have to render works offline unless
they are doing something quite exceptional in terms of audio processing.
The modern expectation is that, on a commercial sequecer, one can update a sequence during its loop,
for example, and hear the change on the next pass.
This is efficient in terms of composition, and provides the ability to use the ear as the judgement source as ideas are explored.
Languages in the Lisp family (and some others) also allow this kind of workflow during software development,
an idiom know as interactive programming, or REPL-driven development (REPL being a reference to the Read Evaluate Print Loop).
In this style of developmen, code is updated while the program is running, allowing an exploratory style of development
that is ideal during early prototyping.
For the domain of algorithmic music, this provides the same immediacy one
gets with sequencers that allow updating data during playback.
Indeed, there exists an entire musical community dedicated to this kind of music programming,
known as “Live Coding”, in which the performer takes the stage with minimal advanced material prepared
and composes in the programming language in view of the audience (often with the code projected on screen).
The project should support this style of working and performing.</p>
</section>
<section id="conclusion">
<h2>Conclusion<a class="headerlink" href="#conclusion" title="Permalink to this heading">¶</a></h2>
<p>By explicitly itemizing the motivational goals and requirements of the project, I can
better describe why the design choices I made (Max, s7 Scheme) make sense,
and evaluate whether the project as a whole is successful.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">M.Tech Thesis</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction - TODO</a></li>
<li class="toctree-l1"><a class="reference internal" href="background.html">Background - Computer Music Programming Languages (4300 words)</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Project Goals and Motivation - 1500 words</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#focus-on-programming-musical-events-and-event-oriented-tools">1) Focus on programming musical events and event-oriented tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="#support-multiple-contexts-scored-composition-realtime-interaction-and-live-performance">2) Support multiple contexts: scored composition, realtime interaction, and live performance</a></li>
<li class="toctree-l2"><a class="reference internal" href="#support-advanced-functional-and-object-oriented-programming-techniques">3) Support advanced functional and object-oriented programming techniques</a></li>
<li class="toctree-l2"><a class="reference internal" href="#be-linguistically-optimized-for-the-target-use-cases">4) Be linguistically optimized for the target use cases</a></li>
<li class="toctree-l2"><a class="reference internal" href="#be-usable-in-conjunction-with-modern-commercial-tools">5) Be usable in conjunction with modern, commercial tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="#support-composing-music-that-is-impractical-on-commercial-tools">6) Support composing music that is impractical on commercial tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="#enable-iterative-development-during-musical-playback">7) Enable iterative development during musical playback</a></li>
<li class="toctree-l2"><a class="reference internal" href="#conclusion">Conclusion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="design.html">High-Level Design (4775 words)</a></li>
<li class="toctree-l1"><a class="reference internal" href="features_usage.html">Features and Usage  (4760 words)</a></li>
<li class="toctree-l1"><a class="reference internal" href="conclusion.html">Conclusion - TODO</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="background.html" title="previous chapter">Background - Computer Music Programming Languages (4300 words)</a></li>
      <li>Next: <a href="design.html" title="next chapter">High-Level Design (4775 words)</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, Iain C. T. Duncan.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.2.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/goals.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>